import numpy as np

from itypez import PixelBasis, CalculationKind
from window_point import WindowPoint


PIXEL_COUNT = 480
DIMENSION_MIN = -1
DIMENSION_MAX = 1

PIXEL_WIDTH = 640
PIXEL_HEIGHT = 480
OUTPUT_SHAPE = [PIXEL_HEIGHT, PIXEL_WIDTH]

TOP = 1
BOTTOM = -1
LEFT = 1
RIGHT = -1


def check_resolution(pixel_height, pixel_width, pixel_unit):
    """
    Ensure that pixel_height x pixel_width can be evenly composed of pixels that are (pixel_unit x pixel_unit)
    in size.  For example, (480x640) resolution cannot be expressed with pixel sizes of either 12 or 64.  Although
    480 / 12 = 40 and 640 / 64 = 10, the other dimension fails to divide evenly, with 640/12 = 53.3333 and
    480 / 64 = 7.5.  But this resolution may use a pixel size of 20, because 480/20 = 24 and 640/20 = 32.
    """
    assert (pixel_height / pixel_unit) == (pixel_height // pixel_unit)
    assert (pixel_width / pixel_unit) == (pixel_width // pixel_unit)
    return True


def check_proportions(
    pixel_height: int, pixel_width: int,
    window_y: float, window_x: float,
    window_width: float, window_point: WindowPoint
) -> (float, float, float, float):
    window_height = window_width * pixel_height / pixel_width
    if window_point == WindowPoint.UPPER_LEFT:
        bottom = window_y - window_height
        right = window_x + window_width
        left = window_x
        top = window_y
    elif window_point == WindowPoint.LOWER_RIGHT:
        bottom = window_y
        right = window_x
        left = window_x - window_width
        top = window_y + window_height
    elif window_point == WindowPoint.CENTER:
        bottom = window_y - (window_height / 2.0)
        right = window_x + (window_width / 2.0)
        left = window_x - (window_width / 2.0)
        top = window_y + (window_height / 2.0)
    else:
        raise RuntimeError(f"Unrecognized window point enum value, {window_point}")
    return bottom, top, left, right


# def deprecated():
    # fix_scale = ratio / pixel_ratio
    # if fix_by == 'to_fit':
    #     if pixel_ratio < ratio:
    #         top = top / fix_scale
    #         bottom = bottom / fix_scale
    #     else:
    #         left = left * fix_scale
    #         right = right * fix_scale
    # elif fix_by == 'to_fill':
    #     if pixel_ratio > ratio:
    #         top = top / fix_scale
    #         bottom = bottom / fix_scale
    #     else:
    #         left = left * fix_scale
    #         right = right * fix_scale
    # else:
    #     raise ValueError(f"{fix_by} is neither 'matched', 'to_fit', or 'to_fill'")
    # return bottom, top, left, right


def _count_pixels(pixel_max, pixel_min=0, pixel_unit=1, dtype=np.uint16):
    return np.fromiter(
        range(pixel_min, pixel_max, pixel_unit),
        count=(pixel_max - pixel_min) // pixel_unit,
        dtype=dtype)


def compute_dicom_default_linear_dimensions(
    pixel_height: int, bottom: int, top: int,
    pixel_width: int, left: int, right: int,
    pixel_basis: PixelBasis = PixelBasis.BOUNDARIES,
    pixel_unit: int = 1
):
    """
    See C.11.2.1 of http://dicom.nema.org/medical/dicom/current/output/html/part03.html#sect_5.3
    """
    pixel_heights = _count_pixels(pixel_height, pixel_unit=pixel_unit)
    pixel_lengths = _count_pixels(pixel_width, pixel_unit=pixel_unit)
    if pixel_basis == PixelBasis.CENTERS or pixel_basis == PixelBasis.CORNERS:
        pixel_height = pixel_height + 1
        pixel_width = pixel_width + 1
    elif pixel_basis != PixelBasis.BOUNDARIES:
        raise RuntimeError(f"Invalid pixel basis: {pixel_basis}")
    pixel_mid_height = pixel_height / 2.0
    pixel_mid_width = pixel_width / 2.0
    range_height = top - bottom
    range_width = right - left
    offset_height = ((0.5 - ((pixel_mid_height - 0.5) / (pixel_height - 1))) * range_height) + bottom
    offset_width = ((0.5 - ((pixel_mid_width - 0.5) / (pixel_width - 1))) * range_width) + left
    frame_heights = np.array([((x * range_height) / (pixel_height - 1)) + offset_height for x in pixel_heights])
    frame_lengths = np.array([((x * range_width) / (pixel_width - 1)) + offset_width for x in pixel_lengths])
    if pixel_basis == PixelBasis.CENTERS:
        shift_height = (frame_heights[1] - frame_heights[0]) / 2.0
        shift_length = (frame_lengths[1] - frame_lengths[0]) / 2.0
        frame_heights = frame_heights + shift_height
        frame_lengths = frame_lengths + shift_length
    return pixel_heights, frame_heights, pixel_lengths, frame_lengths


def compute_dicom_exact_linear_dimensions(
    pixel_height: int, bottom: int, top: int,
    pixel_width: int, left: int, right: int,
    pixel_basis: PixelBasis = PixelBasis.CORNERS,
    pixel_unit: int = 1
):
    """
    See C.11.3.1 of http://dicom.nema.org/medical/dicom/current/output/html/part03.html#sect_5.3
    """
    pixel_heights = _count_pixels(pixel_height, pixel_unit=pixel_unit)
    pixel_lengths = _count_pixels(pixel_width, pixel_unit=pixel_unit)
    if pixel_basis == PixelBasis.BOUNDARIES:
        raise RuntimeError(f"Invalid pixel basis: {pixel_basis}")
    range_height = top - bottom
    range_width = right - left
    pixel_mid_height = pixel_height / 2.0
    pixel_mid_width = pixel_width / 2.0
    offset_height = ((0.5 - (pixel_mid_height / pixel_height)) * range_height) + bottom
    offset_width = ((0.5 - (pixel_mid_width / pixel_width)) * range_width) + left
    frame_heights = np.array([(x * range_height / pixel_height) + offset_height for x in pixel_heights])
    frame_lengths = np.array([(x * range_width / pixel_width) + offset_width for x in pixel_lengths])
    if pixel_basis == PixelBasis.CENTERS:
        shift_height = (frame_heights[1] - frame_heights[0]) / 2.0
        shift_length = (frame_lengths[1] - frame_lengths[0]) / 2.0
        frame_heights = frame_heights + shift_height
        frame_lengths = frame_lengths + shift_length
    return pixel_heights, frame_heights, pixel_lengths, frame_lengths


def compute_sigmoid_dimensions(
    pixel_height: int, bottom: int, top: int,
    pixel_width: int, left: int, right: int,
    pixel_basis: PixelBasis = PixelBasis.BOUNDARIES,
    pixel_unit: int = 1
):
    pixel_heights = _count_pixels(pixel_height, pixel_unit=pixel_unit)
    pixel_lengths = _count_pixels(pixel_width, pixel_unit=pixel_unit)
    pixel_mid_height = pixel_height / 2.0
    pixel_mid_width = pixel_width / 2.0
    if pixel_basis == PixelBasis.CENTERS or pixel_basis == PixelBasis.CORNERS:
        pixel_height = pixel_height + 1
        pixel_width = pixel_width + 1
    elif pixel_basis != PixelBasis.BOUNDARIES:
        raise RuntimeError(f"Invalid pixel basis: {pixel_basis}")
    range_height = top - bottom
    range_width = right - left
    frame_heights = np.array([bottom + (range_height / (1 + np.exp(-8 * (x - pixel_mid_height) / pixel_height))) for x in pixel_heights])
    frame_lengths = np.array([left + (range_width / (1 + np.exp(-8 * (x - pixel_mid_width) / pixel_width))) for x in pixel_lengths])
    if pixel_basis == PixelBasis.CENTERS:
        shift_height = (frame_heights[1] - frame_heights[0]) / 2.0
        shift_length = (frame_lengths[1] - frame_lengths[0]) / 2.0
        frame_heights = frame_heights + shift_height
        frame_lengths = frame_lengths + shift_length
    return pixel_heights, frame_heights, pixel_lengths, frame_lengths


# def compute_nested_linear_dimensions(pixel_height, bottom, top, pixel_width, left, right, pixel_unit=1):
#     """
#     Computes the coordinates for an inside region where distance from frame
#     perimiter coordintes to the location of the first and last pixels is equal
#     to the distance between each pixel.  The mapping from [0, n-1] returned by
#     this function is the same as the [1, n] subrange of a corner-aligned linear
#     spacing into n+2 points
#     a regular linear decomposition of the same boundary positions but n+2
#     points.
#     """
#     frame_heights = np.linspace(bottom, top, 3*pixel_height//pixel_unit, endpoint=True) \
#         .reshape([pixel_height//pixel_unit, 3]) \
#         .transpose([1, 0])[1]
#     frame_lengths = np.linspace(left, right, 3*pixel_width//pixel_unit, endpoint=True) \
#         .reshape([pixel_width//pixel_unit, 3]) \
#         .transpose([1, 0])[1]
#     pixel_heights = _count_pixels(pixel_height, pixel_unit=pixel_unit)
#     pixel_lengths = _count_pixels(pixel_width, pixel_unit=pixel_unit)
#     return pixel_heights, frame_heights, pixel_lengths, frame_lengths

def compute_numpy_dimensions(
    pixel_height: int, bottom: int, top: int,
    pixel_width: int, left: int, right: int,
    pixel_basis: PixelBasis = PixelBasis.CENTERS,
    pixel_unit: int = 1
):
    if pixel_basis == PixelBasis.CENTERS or pixel_basis == PixelBasis.CORNERS:
        endpoint = False
    elif pixel_basis == PixelBasis.BOUNDARIES:
        endpoint = True
    else:
        raise RuntimeError(f"Invalid pixel basis: {pixel_basis}")

    frame_heights = np.linspace(bottom, top, pixel_height//pixel_unit, endpoint=endpoint, retstep=True)
    frame_lengths = np.linspace(left, right, pixel_width//pixel_unit, endpoint=endpoint, retstep=True)
    if pixel_basis == PixelBasis.CENTERS:
        frame_heights = frame_heights[0] + (frame_heights[1] / 2)
        frame_lengths = frame_lengths[0] + (frame_lengths[1] / 2)
    else:
        frame_heights = frame_heights[0]
        frame_lengths = frame_lengths[0]

    pixel_heights = _count_pixels(pixel_height, pixel_unit=pixel_unit)
    pixel_lengths = _count_pixels(pixel_width, pixel_unit=pixel_unit)
    return pixel_heights, frame_heights, pixel_lengths, frame_lengths


# def compute_optical_dimensions(pixel_height, bottom, top, pixel_width, left, right, pixel_unit=1):
#     frame_heights = np.linspace(bottom, top, pixel_height//pixel_unit, endpoint=True)
#     frame_lengths = np.linspace(left, right, pixel_width//pixel_unit, endpoint=True)
#     pixel_heights = _count_pixels(pixel_height, pixel_unit=pixel_unit)
#     pixel_lengths = _count_pixels(pixel_width, pixel_unit=pixel_unit)
#     return pixel_heights, frame_heights, pixel_lengths, frame_lengths


# def compute_dimensions(pixel_height, bottom, top, pixel_width, left, right, pixel_unit=1):
#     frame_heights = np.linspace(bottom, top, pixel_height//pixel_unit, endpoint=False, retstep=True)
#     frame_heights = frame_heights[0] + (frame_heights[1] / 2)
#     frame_lengths = np.linspace(left, right, pixel_width//pixel_unit, endpoint=False, retstep=True)
#     frame_lengths = frame_lengths[0] + (frame_lengths[1] / 2)
#     pixel_heights = _count_pixels(pixel_height, pixel_unit=pixel_unit)
#     pixel_lengths = _count_pixels(pixel_width, pixel_unit=pixel_unit)
#     return pixel_heights, frame_heights, pixel_lengths, frame_lengths

def plot_points(pixel_heights, frame_heights, pixel_lengths, frame_lengths):
    height_count = len(pixel_heights)
    length_count = len(pixel_lengths)
    assert height_count == len(frame_heights)
    assert length_count == len(frame_lengths)
    # Frame matrix
    frame_height_matrix  = frame_heights.reshape([height_count, 1]).repeat(length_count, 1)
    frame_length_matrix = frame_lengths.reshape([1,length_count]).repeat(height_count, 0)
    frame_points = np.array([frame_height_matrix, frame_length_matrix]).transpose(1, 2, 0)
    # Pixel matrix
    pixel_height_matrix  = pixel_heights.reshape([height_count, 1]).repeat(length_count, 1)
    pixel_length_matrix = pixel_lengths.reshape([1,length_count]).repeat(height_count, 0)
    pixel_points = np.array([pixel_height_matrix, pixel_length_matrix]).transpose(1, 2, 0)
    # TODO: Combine these two [x, y, 2] shaped matrices into a single [x, y, 4] matrix?
    return pixel_points, frame_points

