package name.jchein.ptflibs.identity.ulid;

import java.math.BigInteger;

import org.hibernate.validator.constraints.Range;

import name.jchein.ptflibs.math.field.ForkResetSpliteratorOfLong;
import name.jchein.ptflibs.math.field.PrimePowerField;

public abstract class V1AbstractULIDRandomBitsStrategy implements ULIDRandomBitsStrategy {
	private byte variant;

	private int epochBits;
	private int epochShift;
	private long fromLongEpochMask;
	private BigInteger toLongEpochMask;
	
	private int seriesBits;
	private int seriesShift;
	private PrimePowerField seriesSource;
	private ForkResetSpliteratorOfLong seriesIterator;
	private long fromLongSeriesMask;
	private BigInteger toLongSeriesMask;

	private int clockBits;
	private long fromLongClockMask;
	private BigInteger toLongClockMask;

	private BigInteger resetBits;
	private BigInteger randomBits;
	
	protected int randHi16;
	protected long randHi40;
	protected long randLo40;
	protected long randLo64;

//	protected AbstractULIDRandomBitsStrategy() {
//		this(0, 0, 0, 0);
//	}

	/* int randHi16, long randHi40, long randLo40, long randLo64) { */
	protected V1AbstractULIDRandomBitsStrategy(
		@Range(min = 0, max = 7) byte variant,
		@Range(min = 0, max = 63) int epochBits,
		@Range(min = 0, max = 31) int seriesBits,
		@Range(min = 3, max = 15) int clockBits
	) {
		final int totalBits =
			epochBits + Constants.VARIANT_BITS_LEN + seriesBits + clockBits;
		if (totalBits != 80) {
			throw new IllegalArgumentException("Bit counts add to " + totalBits + ", not 80");;
		}
		this.variant = variant;
		this.epochBits = epochBits;
		this.epochShift = 80 - epochBits;
		this.fromLongEpochMask = (0x1L << epochBits) - 1;
		this.toLongEpochMask = BigInteger.valueOf(this.fromLongEpochMask)
			.shiftLeft(this.epochShift);

		this.seriesBits = seriesBits;
		this.seriesShift = 80 - epochBits - seriesBits;
		this.seriesSource = PrimePowerField.generateField(
			seriesBits,
			Constants.MIN_SERIES_FIELD_PRIME_BITS,
			Constants.MAX_SERIES_FIELD_PRIME_BITS
		);
		this.seriesIterator = this.seriesSource.findBasePrimeGenerator();
		this.fromLongSeriesMask = (0x1L << seriesBits) - 1;
		this.toLongSeriesMask = BigInteger.valueOf(this.fromLongSeriesMask)
			.shiftLeft(this.seriesShift);

		this.fromLongClockMask = (0x1L << seriesBits) - 1;
		this.toLongClockMask = BigInteger.valueOf(this.fromLongClockMask)
			.shiftLeft(Constants.CLOCK_BITS_SHIFT);
		this.randHi16 = randHi16;
		this.randHi40 = randHi40;
		this.randLo40 = randLo40;
		this.randLo64 = randLo64;
	}

	public void onBackTick4040(Random4040Callback callback) {
		this.onBackTick();
		callback.accept(this.randHi40, this.randLo40);
	}

	public void onBackTickIntLong(RandomIntLongCallback callback) {
		this.onBackTick();
		callback.accept(this.randHi16, this.randLo64);
	}

	/**
	 * Signals "next" and the beginning of a new clock tick. Generators that either
	 * use state to produce a deterministic sequence of values or to remember a past
	 * history of values may use this signal to rewind to repeat previously used
	 * values, since those values are certain to be paired with different clock
	 * values now.
	 */
	public void onClockTick4040(Random4040Callback callback) {
		this.onClockTick();
		callback.accept(this.randHi40, this.randLo40);
	}

	public void onClockTickIntLong(RandomIntLongCallback callback) {
		this.onClockTick();
		callback.accept(this.randHi16, this.randLo64);
	}

	/**
	 * Signals next, but with the clock value unchanged. Generators should advance
	 * to return their next value, or if using random values without a concept of
	 * sequence, a different value at any rate.
	 */
	public void onNext4040(Random4040Callback callback) {
		this.onNext();
		callback.accept(this.randHi40, this.randLo40);
	}

	public void onNextIntLong(RandomIntLongCallback callback) {
		this.onNext();
		callback.accept(this.randHi16, this.randLo64);
		;
	}

//	protected abstract void onBackTick();

//	protected abstract void onClockTick();

//	protected abstract void onNext();
	
	protected abstract long 
	protected void onBackTick() {
		this.onNext();
		this.resetHi16 = this.randHi16;
		this.resetHi40 = this.randHi40;
		this.resetLo40 = this.randLo40;
		this.resetLo64 = this.randLo64;
	}
	
	protected void onClockTick() {
		this.randHi16 = this.resetHi16;
		this.randHi40 = this.resetHi40;
		this.randLo40 = this.resetLo40;
		this.randLo64 = this.resetLo64;
	}
	
	protected void onNext() {
		if (this.randLo40 == Constants.BASE_RANDOM_LO_40_MASK) {
			if (this.randHi40 == Constants.BASE_RANDOM_LO_40_MASK) {
				this.randLo40 = 0;
				this.randHi40 = 0;
				this.randLo64 = 0;
				this.randHi16 = 0;
				return;
			}
			this.randLo40 = 0;
			this.randHi40 = this.randHi40 + 1;
			
			if (this.randLo64 == Constants.BASE_RANDOM_LO_64_MASK) {
				this.randLo64 = 0;
				this.randHi16 = this.randHi16 + 1;
			} else {
				this.randLo64 = this.randLo64 + 1;
			}
		} else {
			this.randLo40 = this.randLo40 + 1;
			this.randLo64 = this.randLo64 + 1;
		}
	}

}